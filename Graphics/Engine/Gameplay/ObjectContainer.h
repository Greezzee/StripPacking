#pragma once
#include "ObjectsArray.h"

/*!
* Класс игрового поля.
* Создаётся какой-либо сценой и управляется ей.
* Хранит игровые объекты и производит менеджмент ими
* 
* Можно создать несколько игровых полей одновременно
* 
* На данный момент прописан вызов одного игрового поля в Gameplay Scene. Если дополнительных игровых сцен не будет
* игровое поле будет единственным. В этом случае все функции вызываются автоматически из сцен.
* 
* Хранение объектов основано на системе слоёв.
* Существует один основной массив объектов, в котором лежат абсолютно все игровые объекты.
* Слой - подмножество множества игровых объектов
* Один объект может находиться на любом количестве доступных слоёв (в том числе и не находиться ни на одном).
* Такая система позволяет ускорить взаимодействие объектов.
* Например, Player находится на слое Red, его снаряды Bullet также на слое Red, вражеские Bullet на слое Blue
* Чтобы проверить касание игрока вражеских снарядов, достаточно пробежаться только по слою Blue, что проигнорирует объекты слоя Red.
* 
* Система взаимодействия объектов находится в разработке
* 
* Init, Update, Destroy МОЖНО ИЗМЕНЯТЬ
* 
* Остальное НЕ ТРОГАТЬ
*/

class ObjectContainer
{
public:
	//! Инициализация пустого поля (без объектов).
	void Init();

	//! Инициализация пустого поля (без объектов) с заданным числом
	//! макс. кол-ва объектов и слоёв
	void Init(unsigned max_obj, unsigned layers_count);

	//! Уничтожение игрового поля и очистка всей памяти
	void Destroy();

	/*!
	* Создать новый игровой объект. Заполнять GameobjectSpawnData вручную, выделять память под новый объект ВРУЧНУЮ
	* GameobjectSpawnData содержит:
	*	Указатель на сам объект. Он уже должен быть создан, память под него выделена и он проинициализирован.
	*	Массив bool'ов, которые указывает, на каких слоях объект присутствует. Все слои строго пронумерованы
	*/
	void SpawnObject(const GameobjectSpawnData& new_object);

	/*!
	* Уничтожение объекта. Автоматически очищает память и вызывает Destroy по окончанию кадра.
	* Принимает указатель на объект, работает очень быстро
	*/
	void KillObject(const GameObject* object);

	/*!
	* Вызывается после каждого кадра. Окончательно удаляет все объекты.
	* Удаление объектов общей массой после окончания кадра позволит избежать вероятности, что в один цикл Update всех объектов
	* среди них будут существовать удалённые
	*/
	void ClearKilledObjects();

	void ApplyToAllObjects(void (*func)(GameObject*, void*), void* data = nullptr);
	void ApplyToLayerObjects(unsigned layer_id, void(*func)(GameObject*, void*), void* data = nullptr);

	virtual ~ObjectContainer() {};
private:

	/*!
	* Уничтожение объекта. Автоматически очищает память и вызывает Destroy по окончанию кадра.
	* Принимает динамический ID объекта (можно получить с помощью GetID), имеет сложность O(1)
	*/
	void KillObject(const unsigned ID);

	tge::ObjectsArray* _objects = nullptr;//! список всех объектов. Подробнее в одноименном файле
};

